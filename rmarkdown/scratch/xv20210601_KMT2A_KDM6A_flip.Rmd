---
title: "xv2020503_follow_up_indel_processing"
output: html_document
---

## Indel processing script - Usual script we use

# This is the processsing that I will use for Screening processing - Modification of ruben's script (IndelProcessing.Rmd)

The aim of this script is to process and clean the dataframe -> Generate dt with as little as possbile varibles for the whole screen.

## Description of Data

For this analysis we need the mapping and the indel data of the TRIP integrations. These 
files are obtained with the crispr_trip.snake script that C. Leemans edited. This data 
contains the genomic locations of the TRIP integrations (hg38) and the indel frequencies 
at each integration.

The mutations were called by counting the distance between two constant regions. These
were separated by barcode. The barcodes were also filtered on the starcode, to pick out
the most abundant, and considered real, ones.

Mutations files : *count.table

| barcode  | call | indel | count
| ------- | --------- | ----- | ------ |
| TTCTATTCGCACACAA | ins | 1 | 35 |
| TTTCCCACATCAGGAG | wt | 0 | 67 |
| CCATAGTAGTGATTAC | del | -4 | 1 |

Barcode files: *starcode file

| barcode | counts | variants |
| --------|--------|----------|
|TTCTATTCGCACACAA | 2345 | .... |

Note: Indel python pipeline keeps updating, so its output files. This file might need some minor changes to adjust to snakemake output. 

# Data importing and processing
## Path, Libraries, Parameters and Useful Functions
```{r setup, message=FALSE, warnings=FALSE}
knitr::opts_chunk$set(echo = TRUE)
StartTime <-Sys.time()

# 6-digit Date tag:
Date <- substr(gsub("-", "",Sys.time()),1,8) 

# libraries:
library(tidyverse)
library(data.table)
# library(car)
library(parallel)
library(gtools)
```



## Indel data import
Indel and bc data will be imported for further analysis, I am writing this in the following two chunks

```{r import}
# Set directory to the mutation output folder of the CRISPR-TRIP snakemake script
setwd("/DATA/projects/DSBrepair/data/xv20210430_CRISPR_follow_up/indelPCR_counts")
# Import files in list and make individual tables
# I use this if all the samples are good. Here however I do not use all the samples. 
file.list <- list.files(".",
    pattern='*[.]co', full.names=T)

# import the data
df.list.indel <- mclapply(file.list, read.table, col.names=c('barcode', 'call', 'indel', 'count'), mc.cores = 20, stringsAsFactors = FALSE, header=T)
# rename the lists
names(df.list.indel) <- gsub('.*?/(.*?)[.]co.*', '\\1', file.list)

# count the sample number
n.samples.indel <- length(df.list.indel)

```

### Some data pre-processing
Set everything in a dataframe that contains barcodes, indel ratios, and efficiencies.
```{r indeldataframe}
# Generate a datatable with the number of indelreads per mutations, sample and barcode 
mut.list = mclapply(names(df.list.indel), function(exp){
    dt = data.table(df.list.indel[[exp]])
    dt[, indel:=as.character(indel)]
    dt[call=='wt' & indel=='2', indel:='ssODN']
    sum_count = data.table(exp=exp,
                           dt[, list(count=sum(count)),by=c('barcode', 'indel')])
    count_cast = data.table::dcast(sum_count[!is.na(indel),], exp + barcode ~ indel,
                      value.var='count')
    return(count_cast)
}, mc.cores=10)

#Bind all data frames (one per sample) together

indels.dt = do.call(rbind, c(mut.list, fill=T))
indels.dt[is.na(indels.dt)] = 0

#Change colnames in indels.dt

indel_cols <- names(indels.dt)[grep("[0-9]|ssODN|Inf", names(indels.dt))]
indel_cols <- gsub("-", "del_", indel_cols)
indel_cols[grep("^[0-9].*", indel_cols)] <- gsub("^", "ins_", indel_cols[grep("^[0-9].*", indel_cols)])
indel_cols[grep("ins_0", indel_cols)] <- "wt"
names(indels.dt) <- c("exp", "barcode", indel_cols)


# List of barcodes that are in the clone #5 

barcodes.list <- c("AGGGCGTAAAATATTT", "TATGGCTGTCGGGTAG", "TGTCCCTTAGTACTTT", "AGAAAATAATATGACG", "CGGCCTGAAGGTCAGG", "TTGAACGCGGGCTCGG", "GCTAACATCACGAATC", "GCGCACCCTTTAATTG", "ACTGTCGAGTTGTCCG", "CCGGGGACGTATGCAC", "TCTTTTGAGGAGCTGA", "ATATCGTTGCTGGAGA", "CATCCACCACACTTCA", "ACCCCTAAAGGCGCTG", "ATACTATATTTAACGG", "GAGCGCGTCACCGGGT", "GTACCTCTCGATAGTG", "TGGCCAATATTTGTCT", "CATTTCTGATCAATAA")

# Filter both indels and counts dt for the barcodes in the clone

indels.dt <- indels.dt %>% filter(barcode %in% barcodes.list)

## Select plates with nice data (Based on PAO signal)
off.plates <- tibble(plate= c("P1","P2"), t.rep = c("R3","R3"), bio.rep = c("B1","B1"), off = "Yes")

### Pool samples into two bio.reps
#indels.merged.dt <- indels.dt %>% separate(exp, into = c("plate","bio.rep","t.rep","well")) %>% select(-t.rep) %>% dplyr::group_by(plate,bio.rep,well,barcode) %>% dplyr::summarise_all(sum, na.rm = T) %>% mutate(exp = paste(plate,bio.rep,well, sep = "_")) %>% ungroup() %>% select(-plate,-bio.rep,-well)

# Generate indel frequency data table

indels.frequencies.dt = data.frame(indels.dt[,c('exp', 'barcode')],
                                  indels.dt[, c(3:134)] /
                                    rowSums(indels.dt[, c(3:134)]))

# Rename indels.frequencies.dt
indel_pct_cols <- gsub("^", "pct_", indel_cols)
names(indels.frequencies.dt)[3:length(names(indels.frequencies.dt))] <- indel_pct_cols

# Dimensions check

dim(indels.dt)
dim(indels.frequencies.dt)


```

```{r}
# Save all three data frames as a single tibble
indels.tib <- as_tibble(indels.dt)
indels.frequencies.tib <- as_tibble(indels.frequencies.dt)

# Join indels & descr.variables

indels.tib$exp <- gsub("indel_","", indels.tib$exp)
indels.frequencies.tib$exp <- gsub("indel_","", indels.frequencies.tib$exp)

screen.tib <- join(indels.tib,indels.frequencies.tib, by = c("exp","barcode"))

dim(screen.tib)

```
# Plot overall densities of WT, NHEJ and MMEJ
```{r}
# WT
plot(density(screen.tib$pct_wt))
# Ins_1
plot(density(screen.tib$pct_ins_1))
# Del_7
plot(density(screen.tib$pct_del_7))
```


# Save screen data to RDS 
```{r}
# Save RDS
#setwd("~/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/data")
#saveRDS(screen.tib, file = "xv20210510_follow_up_indel_data_merged.rds")
```

## Link to next file
```{r}
#Import and modify metadata file
plate_random_positions <- read.csv("~/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/data/xv20210209_E1383_plate_random.csv") %>% mutate(plate = paste0("P",plate))


# Remove unnecesary columns and add gene info - Filter out wells with less that 30 mutation reads
screen.data.tib <- screen.tib %>% filter(del_7 + ins_1 > 30) %>% 
                                  mutate(indelreads = rowSums(.[, indel_cols]),
                                                  MMEJscore = pct_del_7 / (pct_del_7 + pct_ins_1),
                                                  NHEJscore = pct_ins_1 / (pct_del_7 + pct_ins_1),
                                                  MMEJscore.bis = del_7 / (del_7 + ins_1),
                                                  NHEJscore.bis = ins_1 / (del_7 + ins_1),
                                                  freqMMEJ = pct_del_7,
                                                  freqNHEJ = pct_ins_1,
                                                  freqCut = 1 - pct_wt,
                                                  NHEJMMEJratio = ins_1 / del_7) %>%
                                separate(exp, into = c("plate","bio.rep", "t.rep","well"), sep = "_")

#Change well denotation
screen.data.tib$well = gsub("(?<![0-9])([0-9])(?![0-9])", "0\\1", screen.data.tib$well, perl = TRUE)

#Filter LigIV_combo out


#screen final
screen.data.final <- screen.data.tib %>% left_join(plate_random_positions, by = c("plate","well" = "random_pos")) %>%
                                select(-grep("pct", colnames(.)), -grep("ins",colnames(.)),-grep("del_",colnames(.)), -c("wt","Inf","ssODN")) %>% distinct()


```


# Plot cutting frequency per well/plate
```{r}
# Cutting controls
uncut.control <- screen.data.final %>% dplyr::group_by(well, plate,bio.rep,t.rep) %>% dplyr::mutate(cuteff = mean(freqCut), cut_controls = targets %in% c("no_break","LBR2"))
# Transfection efficiency 
ggplot(uncut.control %>% select(plate, cuteff, cut_controls,targets) %>% filter(cut_controls == T) %>% distinct()) + geom_quasirandom(aes(plate,cuteff, color = targets))

# If I pull out what cells have an average of cuteff > 0.75, I find that only LBR2 + one tracr that has higher cut.eff in P2 R1 B2.
# The plates that have lower cutting efficiency than 0.75 are the following: 
    #P1_B1_R3
    #P1_B2_R2
    #P2_R3_B1
# Do controls in these plates look OK?
#Control plots
control.plots.uncut <- filter(screen.data.final, grepl("POLQ",targets) | grepl("LigIV", targets) | targets == "tracr")
ggplot(control.plots.uncut) + geom_point(aes(MMEJscore,freqCut, color = targets)) + facet_wrap(t.rep ~ bio.rep) + theme_bw()
#Overall my MMEJfreq are quite low in every replicate, but POLQ has an effect in every replicate but B1_R3

# FreqCut controls
cut.control <- screen.data.final %>% filter(targets == "tracr") %>% dplyr::group_by(well, plate,bio.rep) %>% dplyr::mutate(cuteff = mean(freqCut))
ggplot(cut.control %>% select(bio.rep, cuteff,targets) %>% distinct()) + geom_quasirandom(aes(bio.rep,cuteff))

screen.data.final <- screen.data.final %>% filter(!(targets == "LigIV_Combo" & plate == "P1" ) & !(t.rep == "R3" & bio.rep == "B1") & freqCut > 0.15)

```



##Extract WT population
```{r}
# Filter data for only wt DSBs
wt.filter <- screen.data.final %>% filter(targets == "tracr")
wt.followup <- wt.filter %>% dplyr::group_by(barcode,bio.rep) %>% dplyr::summarise(WT.mean = mean(MMEJscore,na.rm = T), WT.sd = sd(MMEJscore,na.rm = T)) %>% right_join(wt.filter, by = c("barcode","bio.rep"))

# Plot frequency plot for each barcode
ggplot(wt.filter) + geom_density(aes(MMEJscore, fill = bio.rep, color = bio.rep), alpha = 0.3) + facet_wrap(~ barcode) + theme_bw() + ggtitle("WT DSBs - MMEJs score distribution")

#Plot mean & sd of each of the barcodes
ggplot(wt.followup) + geom_pointrange(aes(y = reorder(barcode,WT.mean), x = WT.mean, xmin = WT.mean - WT.sd, xmax = WT.mean + WT.sd, color = bio.rep)) + theme_bw() + ggtitle("WT DSBs - MMEJscore distribution (mean +- sd)") + ylab("") + xlab("MMEJscore")

##Control KOs
POLQ.filter <- filter(screen.data.filtered, grepl("POLQ", targets))
LIG4.filter <- filter(screen.data.filtered, grepl("LigIV", targets))

```


#Code for z.score normalization
```{r}

#STEP 1 : Calculate z-scores

# Filter data for on
#Export data for future plots
wt.mmej.score.b <- wt.followup %>% dplyr::select(barcode,bio.rep,MMEJscore = WT.mean) %>% distinct() %>% left_join(new.domains.c5.bis %>% dplyr::select(barcode,chromatin)) %>% mutate(targets = "WT")

# Calculate z-score (per sample)
z.scores.calc.mmej.b <- screen.data.final %>% left_join(wt.followup %>% dplyr::select(barcode,bio.rep,t.rep, WT.mean,WT.sd), by = c("barcode","bio.rep","t.rep")) %>% mutate(z.score = (MMEJscore - WT.mean)/WT.sd) %>% distinct()

#STEP 2 : Combine z-scores per chromatin
ch.z.scores.calc.mmej <- z.scores.calc.mmej.b %>% left_join(new.domains.c5.bis %>% dplyr::select(barcode,chromatin), by = c("barcode")) %>% dplyr::group_by(plate,bio.rep,t.rep, well,chromatin,targets) %>% dplyr::mutate(ch.z.score = mean(z.score, na.rm = T)) %>% distinct()

#gene categories
controls <- c("HDAC5","HMGA1","KDM3A","PICK1","PSMA1")
mll.proteins <- c("ASH2L","RBBP5","WDR5","DPY-30","KDM6A","KMT2A","KMT2C","KMT2D","NCOA6","PA1","PAXIP","KMT2C/D")
other.hits <- c("DPF3","HMG20B","HMGN4","ING1","JARID2","SAP130","SUPT5H")

followup.genes <- c(controls,mll.proteins,other.hits)

# STEP 3: 
cchz.scores.calc.mmej <- ch.z.scores.calc.mmej %>% dplyr::select(bio.rep,t.rep,plate, well,chromatin, targets, ch.z.score) %>% 
    distinct() %>% 
    dplyr::group_by(well,chromatin,targets,plate) %>%
    dplyr::mutate(mmej.SCscore = sum(ch.z.score, na.rm = T)/sqrt(n())) %>%
    ungroup() %>%
    select(well,chromatin,targets,mmej.SCscore) %>%
    distinct() %>%
    dplyr::group_by(chromatin) %>%
    distinct() %>% 
    right_join(ch.z.scores.calc.mmej, by = c("well","targets","chromatin")) %>%
    ungroup() %>% separate(targets, into = c("gene","gRNA")) %>% mutate(category = case_when(gene %in% controls ~ "random",gene %in% mll.proteins ~ "mll_proteins",gene %in% other.hits ~ "other_hits",TRUE ~ "controls"))

#Export all combos
combos.followup <- filter(cchz.scores.calc.mmej, gRNA == "Combo") %>% select(gene, mmej.SCscore,plate,chromatin) %>% distinct()


# STEP 4: Remove variables and export data (filter data that doesn't have a p.value - single value)
#chz.scores.mmej <- cchz.scores.calc.mmej %>% filter(!is.na(targets)) %>% dplyr::select(targets,barcode,chromatin,mmej.SCscore, mmej.ch.score = ch.z.score,MMEJscore,freqCut,mmej.z.score = z.score,bio.rep,t.rep,plate,well)

#STEP 5: dcast genes per chromatin value and replicate
#chz.mmej.dcast <- reshape2::dcast(cchz.scores.calc.mmej %>% ungroup() %>% dplyr::select(gene,gRNA,chromatin,mmej.SCscore) %>% distinct(), targets ~ chromatin, value.var = "mmej.SCscore", fun.aggregate = mean) %>% column_to_rownames("targets")

#combos.dcast <- reshape2::dcast(cchz.scores.calc.mmej %>% filter(grepl("Combo",targets)) %>% ungroup() %>% dplyr::select(targets,chromatin,mmej.SCscore) %>% distinct(), targets ~ chromatin, value.var = "mmej.SCscore", fun.aggregate = mean) %>% column_to_rownames("targets")

#STEP5: dcast genes per p.value
#chz.mmej.pval.dcast <- reshape2::dcast(chz.scores.mmej %>% ungroup() %>% dplyr::select(gene,chromatin,mmej.p.val) %>% distinct(), gene ~ chromatin, value.var = "mmej.p.val")
```
#Make a plot where correlates gRNAs (TIDE and data)
```{r}
#Add TIDE data to it
TIDE <- tibble(targets = c("KDM6A_1","KDM6A_2","KDM6A_3","KDM6A_4","KMT2A_1","KMT2A_2","KMT2A_3","KMT2A_4"), TIDE = c(T,T,F,T,T,T,T,F))
flip.exp <- ch.z.scores.calc.mmej %>% filter(grepl("KMT2A",targets)| grepl("KDM6A",targets)) %>% left_join(TIDE, by = "targets")

#Plot TIDE efficiency
ggplot(flip.exp %>% filter(t.rep == "R2") %>% select(chromatin,ch.z.score, targets,TIDE) %>% distinct() %>% separate(targets, into = c("gene","gRNA"))) + geom_quasirandom(aes(chromatin,ch.z.score, color = gRNA)) + facet_wrap(gene~ TIDE) + theme_bw() + geom_hline(yintercept = 0) + theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```
