---
title: "xv20220623_CCD_preprocessing"
author: "x.vergara"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
  editor_options:
    chunk_output_type: console
---

In this document, I will go over different calculations of epistasis.4 different workflows:
First decision is whether to use log2 MMEJscore or MMEJscore
Second decision is comparing slopes or statistic differences between WT vs. KO slopes
```{r}
knitr::opts_chunk$set(root.dir = '/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/rmarkdown/xv20210920_paper_scripts/short_version/knit_html/')

StartTime <-Sys.time()
library(knitr)

# 8-digit Date tag:
Date <- substr(gsub("-","",Sys.time()),1,8)

#Change in.dir accordingly
in.dir <- "/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/"

#Check if output contain datetag
saveRDS_proof <- function(object, file) {
  document_path <- rstudioapi::getSourceEditorContext()$path %>% str_split(pattern = "/") %>% unlist()
  document_name <- document_path[length(document_path)]
  sys_time <- Sys.time()
  if (grepl(Date, file) == T) {
    write(c(document_name, as.character(sys_time),"Output", correct_file), file = paste0(in.dir,"log"), ncolumns = 4, sep = "\t", append = T)
    saveRDS(object, file)
  }
  else {
    print("Incorrect datetag!")
  }
}

#Read rds check through different versions
readRDS_proof <- function(path, pat) {
  full.path <- paste0(in.dir, path)
  document_path <- rstudioapi::getSourceEditorContext()$path %>% str_split(pattern = "/") %>% unlist()
  document_name <- document_path[length(document_path)]
  sys_time <- Sys.time()
  
  if(file.exists(full.path) == T){
    if(paste0(in.dir,path) != getwd()){
      setwd(paste0(in.dir, path))
  }
    file.list <- list.files(pattern = pat)
    correct_file <- str_sort(file.list, decreasing = T)[1]
    print(correct_file)
    write(c(document_name,as.character(sys_time) ,"Input", correct_file), file = paste0(in.dir,"log"), ncolumns = 4, sep = "\t", append = T)
    readRDS(correct_file)
    
  }
  else{
  setwd(path)
  file.list <- list.files(pattern = pat)
  correct_file <- str_sort(file.list, decreasing = T)[1]
  print(correct_file)
  write(c(document_name, as.character(sys_time),"Input", correct_file),file = paste0(in.dir,"log"), ncolumns = 4, sep = "\t", append = T)
  readRDS(correct_file)
  }
}
```

# Libraries
```{r libraries}
# libraries:
library(tidyverse)
library(reshape2)
library(broom)
library(dendextend)
library(pls)
library(broom)
library(stats)
library(MASS)
library(rstatix)
library(parallel)
library(data.table)
```


# Import raw indel counts from snakemake pipeline from C. Leemans
```{r import}
# Set directory to the mutation output folder of the CRISPR-TRIP snakemake script
setwd("/DATA/projects/DSBrepair/data/xv20210525_ddr_screen_complete/indelPCR_counts")
# Import files in list and make individual tables
# I use this if all the samples are good. Here however I do not use all the samples. 
file.list <- list.files("/DATA/projects/DSBrepair/data/xv20210525_ddr_screen_complete/indelPCR_counts/",
    pattern='*[.]co', full.names=T)

#Filter only samples with data for the experiment
file.list.filtered <- file.list[c(grep("R1_B5", file.list),grep("R2_B4", file.list), grep("R2_B5", file.list))]

# import the data
df.list.indel <- mclapply(file.list.filtered, read.table, col.names=c('barcode', 'call', 'indel', 'count'), mc.cores = 20, stringsAsFactors = FALSE, header=T)

# rename the lists
names(df.list.indel) <- str_extract(file.list.filtered,"P[:digit:].*(?=.co)")

# count the sample number
n.samples.indel <- length(df.list.indel)

#Import other data
clone5_z.score_chrom_tib <- readRDS('/DATA/projects/DSBrepair/data/R/cl20201026_ChIP_zscore_selection.RDS')

#Library KO position
DR_library_info <- read_xlsx("/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/import/Info_well_plate_gene.xlsx") %>% select(well, plate = "Plate", gene)

```

### Process indel calling and filter for real data
Set everything in a dataframe that contains barcodes, indel ratios, and efficiencies.
```{r indeldataframe}
# Generate a datatable with the number of indelreads per mutations, sample and barcode (For this script I will modify this function, to sum replicates with the same ID)
mut.list = mclapply(names(df.list.indel), function(exp){
    dt = data.table(df.list.indel[[exp]])
    dt[, indel:=as.character(indel)]
    dt[call=='wt' & indel=='2', indel:='ssODN']
    sum_count = data.table(exp=exp,
                           dt[, list(count=sum(count)),by=c('barcode', 'indel')])
    count_cast = data.table::dcast(sum_count[!is.na(indel),], exp + barcode ~ indel,
                      value.var='count')
    return(count_cast)
}, mc.cores=10)

#Bind all data frames (one per sample) together

indels.dt = do.call(rbind, c(mut.list, fill=T))
indels.dt[is.na(indels.dt)] = 0

#Change colnames in indels.dt

indel_cols <- names(indels.dt)[grep("[0-9]|ssODN|Inf", names(indels.dt))]
indel_cols <- gsub("-", "del_", indel_cols)
indel_cols[grep("^[0-9].*", indel_cols)] <- gsub("^", "ins_", indel_cols[grep("^[0-9].*", indel_cols)])
indel_cols[grep("ins_0", indel_cols)] <- "wt"
names(indels.dt) <- c("exp", "barcode", indel_cols)


# List of barcodes that are in the clone #5 

barcodes.list <- c("AGGGCGTAAAATATTT", "TATGGCTGTCGGGTAG", "TGTCCCTTAGTACTTT", "AGAAAATAATATGACG", "CGGCCTGAAGGTCAGG", "TTGAACGCGGGCTCGG", "GCTAACATCACGAATC", "GCGCACCCTTTAATTG", "ACTGTCGAGTTGTCCG", "CCGGGGACGTATGCAC", "TCTTTTGAGGAGCTGA", "ATATCGTTGCTGGAGA", "CATCCACCACACTTCA", "ACCCCTAAAGGCGCTG", "ATACTATATTTAACGG", "GAGCGCGTCACCGGGT", "GTACCTCTCGATAGTG", "TGGCCAATATTTGTCT", "CATTTCTGATCAATAA")

# Filter both indels and counts dt for the barcodes in the clone

indels.dt <- indels.dt %>% filter(barcode %in% barcodes.list)

# Generate indel frequency data table

indels.frequencies.dt = data.frame(indels.dt[,c('exp', 'barcode')],
                                  indels.dt[, -c(1:2)] /
                                    rowSums(indels.dt[, -c(1:2)]))

# Rename indels.frequencies.dt
indel_pct_cols <- gsub("^", "pct_", indel_cols)
names(indels.frequencies.dt)[3:length(names(indels.frequencies.dt))] <- indel_pct_cols

# Dimensions check

dim(indels.dt)
dim(indels.frequencies.dt)

# Save all three data frames as a single tibble
indels.tib <- as_tibble(indels.dt)
indels.frequencies.tib <- as_tibble(indels.frequencies.dt)

# Join indels & descr.variables

indels.tib$exp <- gsub("indel_","", indels.tib$exp)
indels.frequencies.tib$exp <- gsub("indel_","", indels.frequencies.tib$exp)

screen.tib <- left_join(indels.tib,indels.frequencies.tib, by = c("exp","barcode"))

dim(screen.tib)

```

#Step 3: Filter and annotate data
```{r}
# Remove unnecesary columns and add gene info - Filter out wells with less that 30 mutation reads
screen.data.ddr <- screen.tib %>% 
  separate(exp, into = c("plate","replicate","batch","well"), remove = F) %>% #Separate sample tag into different elements
  filter(del_7 + ins_1 > 30) %>% #Apply the read number filtering step
  mutate(indelreads = rowSums(.[, indel_cols]),
         freqCut = 1 - pct_wt, #Compute two needed parameters
         log2MMEJNHEJratio = log2(del_7 / ins_1)) %>% 
  mutate(sample = case_when(well %in% c("D6","E6","F6","G6") ~ "WT", #Include type of KO: mock/WT, POLQ, KO or other controls (pipetting or CRISPR eff.)
                            plate == "P6" & well %in% c("H3","H4","H5","H7","H8","H9","H10","H11","H12") ~ "WT",
                            well == "C6" ~ "POLQ",
                            well %in% c("A6","B6","H6") ~ "other_controls",
                            TRUE ~ "KO")) %>%
  mutate(rep = case_when(replicate == "R2" & batch == "B4" ~ "R1", #Final replicate names
                         replicate == "R1" & batch == "B5" ~ "R2",
                         replicate == "R2" & batch == "B5" ~ "R3"))

#Filter wells with mean cutting efficiency lower than 25%
filter.out.wells <- screen.data.ddr %>% 
  dplyr::group_by(well,plate,rep) %>%
  dplyr::summarise(mean.cut = mean(freqCut, na.rm = T)) %>%
  filter(mean.cut < 0.25) %>% 
  dplyr::select(well,plate,rep)

#Filter based on cutting efficiency
filtered.screen.dr <- screen.data.ddr %>% 
  anti_join(filter.out.wells, by = c("plate", "well", "rep"))

#Select variables that will be used downstream
screen.data.tib <- filtered.screen.dr %>%
  select(-grep("pct", colnames(.)), -grep("ins",colnames(.)),-grep("del",colnames(.)), -c("wt","Inf","ssODN","exp"),indelreads, -replicate, -batch, -indelreads) %>% 
  distinct() %>% filter(sample != "other_controls")

#Add DR library info
screen.data.names.tib <- screen.data.tib %>% left_join(DR_library_info, by = c("well","plate"))

```

#This is a analysis pipeline to study chromatin context dependencies (CCD)
#This is a proposal to get to a final version where we can infer statistical significance from the data

#I am currently working on these steps:
  1- log2 MMEJ:NHEJ ratio calculation
  2- Filter based on z-score of this data: Filter genes that have 1 significant IPR (z-score > 1.95) in at least 2 replicates.
  3- Compute log2 MMEJ:NHEJ fold changes based on WT values: Compare with WT samples (This shows that data is reproducible and R are better for KO than WT)
  4- Compute CCDs with WT wells (random CCDs) and KO samples
    A- Table with mean CCDs
    B- Table with all CCDs per replicate
  5- Test for non-random CCDs (KS test, I could even use the WT from the other screen, it won't change much). These are the interactions that matter and they correlate decently between replicates
    A- non-random genes based on mean CCDs
    B- non-random genes based on all CCDs per replicate
  
#Step2: fit normal distribution through wt values
```{r}
#Filter mock transfected samples
WT.values <- filter(screen.data.names.tib , sample == "WT")

#Create empty table to store mean and sd
mean_sd_fits <- tibble(term = NA, estimate = NA, std.error = NA, barcode = NA, rep = NA)

#Function to fit normal distribution through data
for (i in unique(WT.values$rep)) {
  for (x in unique(WT.values$barcode)) {
    single_wt_ratio <- filter(WT.values, rep == i & barcode == x) %>% pull(log2MMEJNHEJratio)
    mean_sd_fits_row <- fitdistr(single_wt_ratio, "normal") %>% tidy()
    mean_sd_fits <- mean_sd_fits %>% add_row(mean_sd_fits_row %>% mutate(barcode = x, rep = i))
  }
}

#Transform the fitted values 
fit.null.distribtution.log2Ratio <- mean_sd_fits %>% 
  reshape2::dcast(barcode + rep ~ term, value.var = "estimate") %>% 
  dplyr::select(barcode, rep, wt.log2ratio = mean, sd.wt.log2ratio = sd)

# Calculate z-scores per IPR-KO combinations with the mean and sd calculated previously
fit.z.scores.ratio.IPR <- screen.data.names.tib %>% 
  left_join(fit.null.distribtution.log2Ratio, by = c("barcode", "rep")) %>% #Join null distribution mean and sd
  na.omit() %>% #remove NA
  mutate(z.score.log2ratio = (log2MMEJNHEJratio - wt.log2ratio)/sd.wt.log2ratio) %>% #calculate z-score value
  dplyr::select(rep, gene, barcode,z.score.log2ratio,sample, well,plate) # select important variables


#Combine replicates
fit.z.scores.ratio.mean <- fit.z.scores.ratio.IPR %>% 
  dplyr::group_by(gene,barcode,sample,well,plate) %>% 
  dplyr::summarise(mean.z.score.IPR = sum(z.score.log2ratio, na.rm = T)/sqrt(n()), count = n()) #combine replicates and check how many values we have for each

# Filter z-scores with two significant IPRs in at least 2 replicates
fit.z.scores.ratio.IPR.filtered <- filter(fit.z.scores.ratio.mean, abs(mean.z.score.IPR) > 1.95 & count > 1) %>% #Filter barcodes that meet criteria
  dplyr::group_by(gene, sample,well,plate) %>% 
  dplyr::summarise(MMEJ_signif = sum(mean.z.score.IPR < -1.95), #Summarise number of significant barcodes per gene and either they favor NHEJ or MMEJ
                   NHEJ_signif = sum(mean.z.score.IPR > 1.95)) %>% 
  filter(MMEJ_signif > 1 | NHEJ_signif > 1) %>% #Filter that significantly perturbs more than one IPR
  mutate(pathway_signif = case_when(MMEJ_signif <= 1 & NHEJ_signif > 1 ~ "NHEJ", #Annotate if a protein favors NHEJ, MMEJ or both
                                    NHEJ_signif <= 1 & MMEJ_signif > 1 ~ "MMEJ", 
                                    T ~ "both"))

```


#Step 3: Compute log2 MMEJ:NHEJ fold changes
```{r}
# Compute log2 fold changes in different set ups for all the KO samples
log2.distance.ratio <- screen.data.names.tib %>% 
  na.omit() %>% #Remove NA
  left_join(wt.set.ratio, by = c("rep", "barcode")) %>% #Join mock KOs
  mutate(log2.foldchange = log2MMEJNHEJratio - wt.log2ratio) %>% #Calculate differential of log2MMEJ:NHEJ 
  dplyr::group_by(gene,well,plate,barcode,sample) %>% #Group by sample
  dplyr::summarise(mean.log2foldchange = mean(log2.foldchange,na.rm = T)) %>% #Compute differential of log2MMEJ:NHEJ
  ungroup()
  
```

#Calculate global MMEJ:NHEJ differentials
```{r}
#Compute mean MMEJ:NHEJ differential over all IPRs
mean.diff.balance <- log2.distance.ratio %>% 
  filter(sample == "KO") %>%
  group_by(gene) %>% 
  dplyr::summarise(mean.fc = mean(mean.log2foldchange, na.rm = T))

#Run t.test with all the data
test.mean.diff.balance <- log2.distance.ratio %>% 
  filter(sample == "KO") %>%
  dplyr::group_by(gene) %>% 
  t_test(mean.log2foldchange ~ 0) %>% 
  mutate(p.adj = p.adjust(p, method = "fdr")) %>% 
  left_join(mean.diff.balance, by = "gene")

#Prepare data frame for export
mean.diff.balance.export <- test.mean.diff.balance %>%
  dplyr::select(gene,p,p.adj,mean.balance.diff = mean.fc)

#Significant MMEJ
mean_significant_MMEJ <- filter(mean.diff.balance.export, p.adj < 0.001 & mean.balance.diff < 0) %>% nrow() #149 proteins favor MMEJ
mean_significant_NHEJ <- filter(mean.diff.balance.export, p.adj < 0.001 & mean.balance.diff > 0) %>% nrow() #16 proteins favor NHEJ

```


# Run the model for DR KO proteins:
```{r}
#Filter genes that do not significantly perturb balance and add chromatin info
DDR.KO.CCD.dt <- log2.distance.ratio %>%
  filter(sample == "KO") %>%
  left_join(clone5_z.score_chrom_tib, by = c("barcode" = "ID")) %>% #Join chromatin info
  left_join(fit.z.scores.ratio.IPR.filtered, by = c("gene", "well", "plate")) %>% na.omit() #Filter genes that do not perturb MMEJ:NHEJ balance

#Create an empty dt with CCDs of DDR proteins
DDR_KO_CCDs_dt <- tibble(gene = NA, r.squared = NA, adj.r.squared = NA,p.value = NA)

for (i in unique(DDR.KO.CCD.dt$gene)){
gene.library.dt <- filter(DDR.KO.CCD.dt, gene == i)
set.seed(1)
PCR_model_DDR_test <- pcr(mean.log2foldchange~CTCF+EZH2+H2AFZ+H3K27ac+H3K27me3+H3K36me3+H3K4me1+H3K4me2+H3K4me3+H3K79me2+H3K9me2+H3K9me3+H4K5acK8ac+HDAC1+HDAC2+HDAC3+POL2+POL2AS2+SMC3+LMNB1+Dam+DNAse+m5C+late_replicating+TTseq, data=gene.library.dt , validation="CV") #Run principal component regression

pcr_pred <- predict(PCR_model_DDR_test, gene.library.dt, ncomp = 3) #Run model with three PC
combined.dt <- tibble(measured = gene.library.dt$mean.log2foldchange, predicted = as.numeric(pcr_pred)) #Create table with real and predicted differentials
pred_vs_estim <- lm(formula = measured ~ predicted, data = combined.dt) %>% glance() #Predicted vs. measured correlation plot
DDR_KO_CCDs_dt <- DDR_KO_CCDs_dt %>% add_row(gene = i, r.squared = pred_vs_estim %>% pull(r.squared), adj.r.squared = pred_vs_estim %>% pull(adj.r.squared), p.value = pred_vs_estim %>% pull(p.value)) #Extract valuable metrics
}

#Correct model to adjust for multiple testing correction (90 genes have chromatin context dependent effects)
adj_p.value_KO_model <- DDR_KO_CCDs_dt %>% dplyr::select(p.value, gene) %>% mutate(sample = "ko") %>% mutate(p.adj = p.adjust(p.value, method = "BH")) %>% dplyr::select(gene,p.value,p.adj, sample)

#Proteins with significant CCDs
DR_prots_signif_CCDs <- adj_p.value_KO_model %>% filter(p.adj < 0.05) %>% nrow() #90 DR proteins have significant CCDs (17.3% of total proteins)

```

#Quality control. Empirical false discovery rate. Run the model for mock KO samples
```{r}
#Average all replicates and prepare data to compute CCDs and global effects
DDR.NT.CCD.dt <- log2.distance.ratio %>% 
  filter(sample == "WT") %>%
  dplyr::group_by(gene,well,plate,barcode) %>% 
  mutate(coordinate = paste0(plate,"_",well)) %>% 
  left_join(clone5_z.score_chrom_tib, by = c("barcode" = "ID"))


#DDR library non-targetting controls (n = 33)
DDR_NT_CCDs_model <- tibble(gene = NA, r.squared = NA, adj.r.squared = NA,p.value = NA)

for (i in unique(DDR.NT.CCD.dt$coordinate)){
gene.library.dt <- filter(DDR.NT.CCD.dt, coordinate == i)
# Run a model per gene
set.seed(1)
PCR_model_DDR_test <- pcr(mean.log2foldchange~CTCF+EZH2+H2AFZ+H3K27ac+H3K27me3+H3K36me3+H3K4me1+H3K4me2+H3K4me3+H3K79me2+H3K9me2+H3K9me3+H4K5acK8ac+HDAC1+HDAC2+HDAC3+POL2+POL2AS2+SMC3+LMNB1+Dam+DNAse+m5C+late_replicating+TTseq, data=gene.library.dt , validation="CV")

pcr_pred <- predict(PCR_model_DDR_test, gene.library.dt, ncomp = 3)
combined.dt <- tibble(measured = gene.library.dt$mean.log2foldchange, predicted = as.numeric(pcr_pred))
pred_vs_estim <- lm(formula = measured ~ predicted, data = combined.dt) %>% glance()
DDR_NT_CCDs_model <- DDR_NT_CCDs_model %>% add_row(gene = i, r.squared = pred_vs_estim %>% pull(r.squared), adj.r.squared = pred_vs_estim %>% pull(adj.r.squared), p.value = pred_vs_estim %>% pull(p.value))
  }

#non-targeting (2 non-targeting values are selected with this value)
adj_p.value_NT_model <- DDR_NT_CCDs_model %>% dplyr::select(p.value, gene) %>% mutate(sample = "nt") %>% mutate(p.adj = p.adjust(p.value, method = "BH")) %>% dplyr::select(gene,p.value,p.adj, sample)

#Proteins with significant CCDs
mock_ko_signif_CCDs <- adj_p.value_NT_model %>% filter(p.adj < 0.05) %>% nrow() #2 mock values have significant CCDs (6% of total proteins)


```

#Step 4: Calculate synergy scores for KO samples: 
```{r}
#Create empty dataframe to calculate synergy scores
DR_KO_CCD_slopes <- tibble(gene = NA, feature = NA, slope.log2 = NA, term = NA,p.value = NA)

for (h in unique(DDR.KO.CCD.dt$gene)) {
  for (j in colnames(DDR.KO.CCD.dt)[8:32]) { #Run this function for each of the 25 high quality chromatin features
    model.dt <- DDR.KO.CCD.dt %>% filter(gene == h) # And For each gene
   if (nrow(model.dt) == 0) {
next
}
    model.epistasis.log2 <- lm(formula = mean.log2foldchange ~ unlist(model.dt[j]), data = model.dt) %>% tidy() #Correlation analysis
   DR_KO_CCD_slopes <- DR_KO_CCD_slopes %>% add_row(gene = h, feature = j, slope.log2 = model.epistasis.log2 %>% pull(estimate), term = model.epistasis.log2 %>% pull(term), p.value = model.epistasis.log2 %>% pull(p.value)) #Select valuable parameters and save them in data frame
  }
}

#Calculate KO proteins (terms)
DR_KO_CCD_all_values <- DR_KO_CCD_slopes %>% 
  reshape2::dcast(gene + feature ~ term, value.var = "slope.log2") %>%  #dcast table
  dplyr::select(gene ,feature,intercept = '(Intercept)', slope = 'unlist(model.dt[j])') %>% #Extract information for slopes only
  left_join(adj_p.value_KO_model %>% 
              dplyr::select(gene, model_p.value = p.value, model_p.adj = p.adj), by = "gene") %>% #Join with CCDs p_value data table and change some names
  left_join(fit.z.scores.ratio.IPR.filtered, by = "gene") %>% #Join with individual IPR significance calls (z-test)
  mutate(cross.x = -intercept/slope, slope_cor = case_when(cross.x < 1 ~ slope, cross.x > 1 ~ 0)) %>% #Compute x intercept and apply x.intercept filter
  mutate(CCD_value = case_when(pathway_signif == "MMEJ" & slope_cor < 0 ~ slope_cor, pathway_signif == "MMEJ" & slope_cor > 0 ~ 0, pathway_signif == "NHEJ" & slope > 0 ~ slope_cor, pathway_signif == "NHEJ" & slope < 0 ~ 0, T ~ slope_cor)) %>% #Call M-synergies, N-synergies or no synergies based on the intercept and MMEJ:NHEJ differentials
  na.omit()

#How many M-, N- and no synergies
synergy_summaries <- DR_KO_CCD_all_values %>% filter(model_p.adj < 0.05) %>% dplyr::group_by(gene) %>% dplyr::summarise(M_synergy = sum(CCD_value < 0), N_synergy = sum(CCD_value > 0)) %>% distinct() %>% mutate(synergy_class = case_when(N_synergy == 0 ~ "M_synergy", M_synergy == 0 ~ "N_synergy", T ~ "both")) %>% dplyr::group_by(synergy_class) %>% dplyr::summarise(c = n())
```

#Compute estimated ∆log2MMEJ:NHEJ scores for CCD effects
```{r}
chromatin_features_plot <-  clone5_z.score_chrom_tib %>% reshape2::melt(id.vars = c("pool","ID","binsize"))

##99% CI for each feature
CI99_chromatin_features <- chromatin_features_plot %>% dplyr::group_by(variable) %>% dplyr::summarise(CI0.5 = quantile(value, 0.005), CI99.5 = quantile(value, 0.995), range = CI99.5 - CI0.5, mean = mean(value))

##DNA repair protein class (CCD, global, both)
global_effect_proteins <- mean.diff.balance.export %>% filter(p.adj < 0.001) %>% pull(gene) %>% unique() #Filter genes with significant global ∆log2MMEJ:NHEJ scores
CCD_proteins <- DR_KO_CCD_all_values %>% filter(model_p.adj < 0.05) %>% pull(gene) %>% unique() #Filter genes with significand CCD ∆log2MMEJ:NHEJ scores
#All classes
both_CCD_global_proteins <- intersect(global_effect_proteins, CCD_proteins) #Check for overlap
only_global <- setdiff(global_effect_proteins, both_CCD_global_proteins) #Only global effects
only_CCD <- setdiff(CCD_proteins, both_CCD_global_proteins) #Only CCDs

# Create a summary table with three protein classes
classes_summary <- tibble(gene = c(both_CCD_global_proteins,only_global,only_CCD), 
                          class = c(rep("both", length(both_CCD_global_proteins)),rep("global",length(only_global)), rep("CCD", length(only_CCD))))

##Compute estimated CCD ∆log2MMEJ:NHEJ score
estimated_FC_CCD <- DR_KO_CCD_all_values %>% 
  left_join(CI99_chromatin_features, by = c("feature" ="variable")) %>% #Join 99% CI for chromatin
  mutate(estim_fc_CCD = range*CCD_value) %>% #Calculate range
  left_join(classes_summary, by = "gene") #Join class they belong

##Select the maximum estimated effect for each gene
max_estimated_FC_CCD_gene <- estimated_FC_CCD %>% 
  dplyr::group_by(gene) %>% 
  dplyr::summarise(m_CCD_FC_nhej = max(estim_fc_CCD), 
                   m_CCD_FC_mmej = min(estim_fc_CCD)) %>% 
  reshape2::melt(value.name = "m_CCD_FC", id.vars = "gene") %>% 
  filter(m_CCD_FC != 0)

## Filter max(CCDs)
max_estimated_CCD_FC <- estimated_FC_CCD %>% 
  mutate(m_CCD_FC = estim_fc_CCD) %>% 
  right_join(max_estimated_FC_CCD_gene) %>% 
  dplyr::select(-m_CCD_FC)

#Left_join mean.fc
estimated_CCD_global <- max_estimated_CCD_FC %>% 
  left_join(mean.diff.balance.export, by = "gene")

```

#Creat table S3: Data to export all major features
```{r}
export_screen_result_TS3 <- estimated_FC_CCD %>% 
  mutate(screen_position = paste0(plate, "_", well)) %>% 
  left_join(mean.diff.balance.export, by = "gene") %>%
  select(gene,screen_position, CCD_model_p_adj = "model_p.adj",chrom_feature = "feature", CCD_synergy_score = "CCD_value",CCD_estim_diff = "estim_fc_CCD", global_diff = "mean.balance.diff", global_p_adj = "p.adj", DR_effect_type = "class")

```


#Output files: Export all files needed for making figures
```{r}
setwd(in.dir)

#Step 1: Raw freqCut & log2MMEJNHEJ values
saveRDS_proof(screen.data.names.tib, file = "data/processed_data/CCD_analysis/xv20220801_screening_raw_data_repair_metrics.rds")

#Step 2: dcast data table for 
saveRDS_proof(log2.distance.ratio, file = "data/processed_data/CCD_analysis/xv20220801_differentials_log2_MMEJ_NHEJ_balance.rds")

#Step 3: z-scores every step
saveRDS_proof(fit.null.distribtution.log2Ratio, file = "data/processed_data/CCD_analysis/xv20220801_z_test_null_distribution_parameters.rds") #Null distribution parameters
saveRDS_proof(fit.z.scores.ratio.IPR, file = "data/processed_data/CCD_analysis/xv20220801_z_test_per_replicate_transformation.rds") #Z-test without any averaging
saveRDS_proof(fit.z.scores.ratio.mean, file = "data/processed_data/CCD_analysis/xv20220801_z_test_final_values.rds") #Z-test values

#Step 4: diff log2 MMEJ:NHEJ values for DR proteins with chromatin scores
saveRDS_proof(DDR.KO.CCD.dt, file = "data/processed_data/CCD_analysis/xv20220801_log2_MMEJNHEJ_differentials_chromatin_KO.rds")

#Final data table: Table S3
saveRDS_proof(export_screen_result_TS3, file = "data/processed_data/xv20220801_Table_S3_DR_screen_results.rds")
write.csv(export_screen_result_TS3, file = "data/processed_data/xv20220801_Table_S3_DR_screen_results.csv")

```
