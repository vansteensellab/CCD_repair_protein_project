---
title: "xv20230329_RPE1_mapping_clone"
author: "Xabier Vergara"
date: "2023-03-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(plotly)
library(ggbeeswarm)
library(pheatmap)
```

# Patwhay balance in clone 32: After mapping

## Import data
```{r, warning=F}
# List files in mcclintock
pathway_assay_files <- list.files("/DATA/projects/DSBrepair/data/xv20230714_E2286_pool_pathway_assay/indelPCR_counts",pattern = '*[.]co', full.names = T) 

#Read and parse files
clone_pools_pathway_assay <- map_dfr(pathway_assay_files, function(x){
  read_delim(x, show_col_types = F) %>% 
  mutate(filename = gsub("/DATA/projects/DSBrepair/data/xv20230714_E2286_pool_pathway_assay/indelPCR_counts/","",x),
         outcome = paste(call, indel, sep = "_")) %>%
  separate(filename, into = c("exp_n","sample_ID","cell_line","condition","bio_rep","t_rep"))
})
```


#Number of mapped IPRs with indel data (most optimistic)
```{r}
selected_pools <- c("RPE1_Low_1000","RPE1Deff_Low_1000","RPE1Proff_Low_250","U2OS_High_100")

#Import barcode sequences
#RPE cells
RPE_IPR <- read_delim("/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/export/xv20230307_revision_figures/DSB_TRIP_mapping/xv20230519_RPE_pools_mapping.tsv") %>%
  select(name) %>%
  separate(name, into = c("barcode","iPCR_cell","iPCR_transfection","iPCR_complexity"))

U2OS_IPR <- read_delim("/home/x.vergara/XV_P3_ChromDSBScreen/xv_CRISPR_screen_figures/export/xv20230307_revision_figures/DSB_TRIP_mapping/xv20230519_U2OS_pools_mapping.tsv") %>%
  select(name) %>%
  separate(name, into = c("barcode","iPCR_cell","iPCR_transfection","iPCR_complexity"))

#Bind both
all_IPRs <- bind_rows(RPE_IPR, U2OS_IPR) %>% mutate(pool = paste(iPCR_cell, iPCR_transfection,iPCR_complexity, sep = "_")) %>% filter(pool %in% selected_pools)
```
#CONCLUSION: We are recovering the whole complexity for U2OS & PRO (input 400 ng). With DEF & RPE we are not capturing full complexity (input 200 ng).


```{r}
#Filter by replicate
indel_data <- clone_pools_pathway_assay %>% 
  dplyr::group_by(barcode,outcome, exp_n, cell_line, condition, bio_rep) %>%
  dplyr::summarise(counts = sum(count, na.rm = F) + 1) %>% left_join(all_IPRs) %>% na.omit()

#Filter out rep
filter_out_rep <- tibble(cell_line = "RPEDef",bio_rep = "R4")

indel_data_clean <- indel_data %>% anti_join(filter_out_rep)


#Only look at LBR2 vs. tracr
control_balance_inh <- indel_data_clean %>% filter(condition %in% c("LBR2","tracr","DNAPKi", "ATMi") & outcome %in% c("ins_1","del_-7","wt_0"))

#Look at read numbers
control_balance_bio_dcast <- control_balance_inh %>% reshape2::dcast(barcode + cell_line + condition + bio_rep ~ outcome, value.var = "counts", fun.aggregate = mean, fill = 1)

#Control_measurements (bio_rep)
pathway_metric_control_bio <- control_balance_bio_dcast %>%
  mutate(balance = `del_-7`/(ins_1 + `del_-7`),
         log2_bal = log2(`del_-7`/ins_1),
         TIF = 1 - (wt_0/(`del_-7`+ins_1+wt_0))) %>%
  na.omit()

#Filter by read number and plot noise level
read_count <- c(0,1,2,5,10,15,20,50,100,200,300)

filter_read_count_test <- map_dfr(read_count , function(x) {
  pathway_metric_control_bio %>%
    filter(`del_-7` >= x & ins_1 >= x) %>%
    mutate(read_filter = x)
})

#Number of IPRs in each
IPR_summary <- filter_read_count_test %>% 
  dplyr::group_by(cell_line, condition, read_filter, bio_rep) %>% 
  dplyr::summarize(IPR_n = n()) 

IPR_summary_dcast <- IPR_summary %>% 
  reshape2::dcast(cell_line + condition + bio_rep ~ read_filter, value.var  = "IPR_n")

#Plot loss of IPRs by each read_count filter

ggplot(IPR_summary) + 
  geom_col(aes(x = bio_rep,
               y = IPR_n,
               fill = fct_relevel(as.character(read_filter),as.character(read_count))),
           position = "dodge") +
  labs(fill = "read_filter") +
  facet_grid(condition~ cell_line, scales = "free") + 
  theme_bw()
```
#Conclusion: we always get some barcodes, but these are extremely low in RPE1 cells

#Is pathway balance reproducible among replicates?
```{r}
read_counts_filter_reprod <- filter_read_count_test %>%
  reshape2::dcast(barcode + cell_line + condition + read_filter ~ bio_rep, value.var = "log2_bal")

#Calculate mean & sd
read_counts_filter_reprod_summary <- read_counts_filter_reprod %>% 
  rowwise() %>% 
  mutate(mean_bal = mean(c(R1,R2,R3,R4),na.rm = T),
         sd_bal = sd(c(R1,R2,R3,R4), na.rm = T),
         reps = 4 - sum(is.na(c(R1,R2,R3,R4))))

ggplot(read_counts_filter_reprod_summary) + 
  geom_point(aes(mean_bal, sd_bal, color = as.character(reps))) +
  facet_grid(read_filter ~ cell_line) +
  theme_bw()

# Balance density
ggplot(read_counts_filter_reprod_summary) + 
  geom_density(aes(mean_bal, color = reps > 1)) +
  facet_grid(read_filter ~ cell_line, scales = "free") +
  theme_bw()


#R1 vs. R2
ggplot(read_counts_filter_reprod_summary, aes(R1,R2)) +
  geom_point(aes(color = as.character(reps))) + 
  geom_smooth(method = "lm") +
  ggpubr::stat_cor() +
  facet_grid(cell_line ~ read_filter, scales = "free")

#R1 vs. R2
ggplot(read_counts_filter_reprod_summary, aes(R2,R3)) +
  geom_point(aes(color = as.character(reps))) + 
  geom_smooth(method = "lm") +
  ggpubr::stat_cor() +
  facet_grid(cell_line ~ read_filter, scales = "free")

#R1 vs. R2
ggplot(read_counts_filter_reprod_summary, aes(R1,R3)) +
  geom_point(aes(color = as.character(reps))) + 
  geom_smooth(method = "lm") +
  ggpubr::stat_cor() +
  facet_grid(cell_line ~ read_filter, scales = "free")

```

#Conclusion: To get high reproducibility in the results, we really need to be very stringent with the cut-off. I will try to repeat a similar filtering with total number of read cut-off and see how it looks.

#Can I filter the other data?
```{r}
tmp <- values_chromatin %>% filter(read_filter == 50) %>% select(barcode, cell_line) %>% distinct()

#Filter values that I got reads in previous filtering
filtered_IPRs <- pathway_metric_control_bio %>% right_join(tmp)

read_counts_filter_inh <- filtered_IPRs %>%
  reshape2::dcast(barcode + cell_line + condition ~ bio_rep, value.var = "log2_bal")

#Calculate mean & sd
read_counts_filtered_IPR <- read_counts_filter_inh %>% 
  rowwise() %>% 
  mutate(mean_bal = mean(c(R1,R2,R3,R4),na.rm = T),
         sd_bal = sd(c(R1,R2,R3,R4), na.rm = T),
         reps = 4 - sum(is.na(c(R1,R2,R3,R4))))

#Control plot
ggplot(read_counts_filtered_IPR) + geom_quasirandom(aes(condition,mean_bal)) + facet_wrap(~cell_line)
```


#Plot summary correlation coefficients
```{r, message=F}
#Test with U2OS & 50
analysis_pair <- read_counts_filtered_IPR %>% select(cell_line, condition) %>% distinct()

replicate_comparisons <- tidyr::crossing(c(1:4),c(1:4))

tmp_f <- map2_dfr(analysis_pair$cell_line,analysis_pair$condition, function(x,y){
  #Filter_data
  data_sel <- read_counts_filter_reprod_summary %>%
    filter(cell_line == x & condition == y) %>%
    select(R1, R2, R3, R4)
  
  #Correlation analyis
cor_data <- cor(data_sel, use = "pairwise.complete.obs", method = "spearman") %>%
  as_tibble(rownames = NA) %>% 
  rownames_to_column(var = "rep_1") %>% 
  reshape2::melt(value.name = "coefficient") %>%
  select(rep_1, "rep_2" = variable, coefficient) %>%
  na.omit() %>% 
  mutate(cell_line = x,
         read_filter = y)

#Number of IPRs per each data table

IPR_n_cor <- map2_dfr(as.vector(as.matrix(replicate_comparisons[1])), as.vector(as.matrix(replicate_comparisons[2])), function(j,i) {
  IPR_count <- data_sel %>% select(j,i) %>% na.omit() %>% nrow()
  tibble(rep_1 = paste0("R",j), rep_2 = paste0("R",i), IPR_n = IPR_count)
})

left_join(cor_data, IPR_n_cor)
  
})

#Plot with data_points in comparison
ggplot(tmp_f) + 
  geom_tile(aes(rep_1, rep_2, fill = coefficient)) + 
  geom_text(aes(rep_1, rep_2, label = IPR_n)) + 
  scale_fill_gradient2() + 
  facet_grid(cell_line ~ read_filter, scales = "free") +
  theme_bw() +
  theme(legend.position = "top")

```


#Calculate differencials
```{R}
#Balance data
control_balance <- read_counts_filtered_IPR %>% filter(condition == "LBR2") %>% select(barcode, cell_line, control_bal = mean_bal)

#Inhibited_bal
inhibitor_balance <- read_counts_filtered_IPR %>% filter(condition %in% c("ATMi","DNAPKi")) %>% select(barcode, cell_line, mean_bal, condition)

#Join both
balance_treated <- inhibitor_balance %>% left_join(control_balance) %>% mutate(diff_bal = mean_bal - control_bal)

```

#Add chromatin info for RPE1 cells
#Load chromatin info of the IPRs in RPE cells
```{r}
setwd("/DATA/projects/DSBrepair/data/DSB_TRIP_cell_lines_mapping/xv20230519_all_RPE_pools_mapping/")
# Load chip data
chip_files <- list.files(path = "chip/site_means", pattern = "2000", full.names = T)
dam_files <- list.files(path = "dam", pattern = "2000", full.names = T)
repli_files <- "coverage/RPE1_DSB_TRIP_pools-2000_summary.tsv"

#Make a dataframe with all the files
chromatin_features_pools_chip <- map(chip_files, function(x) {
  read.delim(x, header = T) %>%
    dplyr::select(ID, z_score) %>%
    na.omit() %>%
    mutate(file = paste0("chip_",str_extract(x, "H.*(?=_)"))) %>%
    reshape2::dcast(ID ~ file, value.var = "z_score")
}) %>% purrr::reduce(left_join, by = "ID")

#Make a dataframe with dam files
chromatin_features_pools_dam <- map(dam_files, function(x) {
  read.delim(x, header = T) %>%
    dplyr::select(name, z_score) %>%
    na.omit() %>%
    mutate(file = paste0("dam_",str_extract(x, "(?<=2000_).*(?=.txt)"))) %>%
    reshape2::dcast(name ~ file, value.var = "z_score")
}) %>% purrr::reduce(left_join, by = "name")

#Make a column for repliseq
repliseq_dataframe <- map_dfr(repli_files, function(x) {
  read.delim(x, header = T) %>%
    na.omit() %>%
    mutate(ratio_r1 = repliseq_r1_late - repliseq_r1_early, ratio_r2 = repliseq_r2_late - repliseq_r2_early) %>%
    mutate(repliseq = (ratio_r1 + ratio_r2)/2) %>%
    dplyr::select("ID" = barcode, repliseq)
})

#Bind both
chromatin_features_pools <-  left_join(chromatin_features_pools_chip, chromatin_features_pools_dam, by = c("ID"="name")) %>%
  left_join(repliseq_dataframe) %>%
  separate(ID, into = c("barcode","iPCR_cell","iPCR_transfection","iPCR_complexity")) %>%
  mutate(pool = paste(iPCR_cell, iPCR_transfection,iPCR_complexity, sep = "_")) %>% 
  filter(pool %in% selected_pools) %>%
  mutate(cell_line = case_when(iPCR_cell == "RPE1Deff" ~ "RPEDef",
                               iPCR_cell == "RPE1Proff" ~ "RPEPro",
                               T ~ iPCR_cell)) %>%
  select(-pool, -iPCR_cell, -iPCR_transfection, -iPCR_complexity)
  
```

#Join with balances and calculate the correlation (do this for all marks)
```{r, warning=F}
values_chromatin <- left_join(balance_treated, chromatin_features_pools) %>% filter(cell_line != "U2OS")

```

```{r}
#Create empty dataframe to calculate synergy scores
drug_CCD_slopes_RPE <- tibble(drug = NA, feature = NA, slope.log2 = NA, term = NA,p.value = NA, cell_line = NA)

#Loop to run linear models on the values
for (h in unique(values_chromatin$condition)) {
  for(i in unique(values_chromatin$cell_line)) {
  for (j in colnames(values_chromatin)[7:16]) { #Run this function for each of the 25 high quality chromatin features
    model.dt <- values_chromatin %>% filter(condition == h & cell_line == i) # And For each gene
   if (nrow(model.dt) == 0) {
next
}
    model.epistasis.log2 <- lm(formula = diff_bal ~ unlist(model.dt[j]), data = model.dt) %>% tidy() #Correlation analysis
   drug_CCD_slopes_RPE <- drug_CCD_slopes_RPE %>% add_row(drug = h, feature = j,cell_line = i, slope.log2 = model.epistasis.log2 %>% pull(estimate), term = model.epistasis.log2 %>% pull(term), p.value = model.epistasis.log2 %>% pull(p.value)) #Select valuable parameters and save them in data frame
  }
  }
}

#Retain slopes that 
drug_CCD_all_values <- drug_CCD_slopes_RPE %>% 
  reshape2::dcast(drug + feature + cell_line ~ term, value.var = "slope.log2") %>%  #dcast table
  dplyr::select(drug, cell_line,feature,intercept = '(Intercept)', slope = 'unlist(model.dt[j])') %>% #Extract information for slopes only
  mutate(CCD_value = case_when(drug == "ATMi" & slope < 0 ~ slope, drug == "ATMi"& slope > 0 ~ 0, drug == "DNAPKi" & slope > 0 ~ slope, drug == "DNAPKi" & slope < 0 ~ 0, T ~ slope)) %>% #Call M-synergies, N-synergies or no synergies based on the slope and MMEJ:NHEJ differentials
  na.omit()

#How many M-, N- and no synergies
synergy_summaries <- drug_CCD_all_values %>% filter(model_p.adj < 0.05) %>% dplyr::group_by(drug) %>% dplyr::summarise(M_synergy = sum(CCD_value < 0), N_synergy = sum(CCD_value > 0)) %>% distinct() %>% mutate(synergy_class = case_when(N_synergy == 0 ~ "M_synergy", M_synergy == 0 ~ "N_synergy", T ~ "both")) %>% dplyr::group_by(synergy_class) %>% dplyr::summarise(c = n())
```
#CONCLUSION: This is quite crazy these CCDs are 5x larger in p53WT background than in p53 null =00000!!!!!!!
